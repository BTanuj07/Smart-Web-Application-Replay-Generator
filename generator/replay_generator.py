import os
import json
from typing import Dict, List
from urllib.parse import urlparse, quote, unquote
import base64

class ReplayGenerator:
    def __init__(self, output_dir: str = "generated_attacks"):
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)

    def generate_advanced_python_script(self, attack: Dict[str, any], attack_id: int) -> str:
        """Generate advanced Python script for real attack simulation."""
        
        raw_url = attack.get('full_url', '')
        method = attack.get('method', 'GET')
        user_agent = attack.get('user_agent', 'Mozilla/5.0')
        attack_type = attack.get('attack_type', 'Unknown')
        matched_payload = attack.get('matched_payload', '')
        
        # Parse URL components
        parsed_url = urlparse(raw_url)
        path = parsed_url.path or '/'
        query = parsed_url.query or ''
        
        script = f'''#!/usr/bin/env python3
"""
Advanced Attack Simulation Script
Attack Type: {attack_type}
Generated by AttackReplay Pro

DISCLAIMER: This script is for authorized security testing only.
Only use on systems you own or have explicit permission to test.
Unauthorized use is illegal and unethical.
"""

import requests
import urllib.parse
import time
import random
import sys
from datetime import datetime

class AttackSimulator:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.attack_info = {{
            "attack_type": "{attack_type}",
            "original_payload": "{matched_payload}",
            "original_ip": "{attack.get('ip', '')}",
            "timestamp": "{attack.get('timestamp', '')}",
            "method": "{method}",
            "user_agent": "{user_agent}"
        }}
        
        # Set up session with realistic headers
        self.session.headers.update({{
            "User-Agent": self.attack_info["user_agent"],
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "keep-alive",
            "Upgrade-Insecure-Requests": "1"
        }})
    
    def print_banner(self):
        print("=" * 70)
        print(f"üéØ ATTACK SIMULATION: {{self.attack_info['attack_type']}}")
        print("=" * 70)
        print(f"Target URL: {{self.target_url}}")
        print(f"Attack Type: {{self.attack_info['attack_type']}}")
        print(f"Method: {{self.attack_info['method']}}")
        print(f"Original Payload: {{self.attack_info['original_payload']}}")
        print(f"Timestamp: {{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}}")
        print("-" * 70)
    
    def simulate_attack(self):
        """Execute the attack simulation."""
        try:
            # Construct the attack URL
            attack_path = "{path}"
            attack_query = "{query}"
            
            if attack_query:
                full_url = f"{{self.target_url}}{{attack_path}}?{{attack_query}}"
            else:
                full_url = f"{{self.target_url}}{{attack_path}}"
            
            print(f"üöÄ Launching attack against: {{full_url}}")
            print(f"üì° Method: {{self.attack_info['method']}}")
            
            # Add random delay to avoid detection
            delay = random.uniform(0.5, 2.0)
            print(f"‚è±Ô∏è  Waiting {{delay:.1f}} seconds...")
            time.sleep(delay)
            
            # Execute the attack
            start_time = time.time()
            '''
        
        if method.upper() == 'GET':
            script += '''
            response = self.session.get(full_url, timeout=15, allow_redirects=False, verify=False)
            '''
        elif method.upper() == 'POST':
            script += '''
            # For POST attacks, you may need to add form data
            post_data = {}  # Add POST data if needed
            response = self.session.post(full_url, data=post_data, timeout=15, allow_redirects=False, verify=False)
            '''
        else:
            script += f'''
            response = self.session.request("{method}", full_url, timeout=15, allow_redirects=False, verify=False)
            '''
        
        script += '''
            end_time = time.time()
            
            # Analyze response
            self.analyze_response(response, end_time - start_time)
            
        except requests.exceptions.Timeout:
            print("‚ö†Ô∏è  Request timed out - possible DoS effect")
        except requests.exceptions.ConnectionError:
            print("‚ùå Connection failed - target may be down or blocking")
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Request failed: {e}")
        except Exception as e:
            print(f"üí• Unexpected error: {e}")
    
    def analyze_response(self, response, response_time):
        """Analyze the attack response for indicators."""
        print(f"\\nüìä RESPONSE ANALYSIS")
        print("-" * 30)
        print(f"Status Code: {response.status_code}")
        print(f"Response Time: {response_time:.2f} seconds")
        print(f"Content Length: {len(response.content)} bytes")
        print(f"Content Type: {response.headers.get('Content-Type', 'Unknown')}")
        
        # Check for common vulnerability indicators
        self.check_vulnerability_indicators(response)
        
        # Show response headers
        print(f"\\nüìã Response Headers:")
        for key, value in response.headers.items():
            print(f"  {key}: {value}")
        
        # Show response preview
        print(f"\\nüìÑ Response Preview (first 500 chars):")
        print("-" * 30)
        try:
            preview = response.text[:500]
            print(preview)
            if len(response.text) > 500:
                print("... [truncated]")
        except:
            print("[Binary content or encoding error]")
    
    def check_vulnerability_indicators(self, response):
        """Check response for vulnerability indicators."""
        indicators = []
        content = response.text.lower() if hasattr(response, 'text') else ''
        
        # SQL Injection indicators
        if any(indicator in content for indicator in ['sql syntax', 'mysql_fetch', 'ora-', 'microsoft jet']):
            indicators.append("üîç Possible SQL Injection vulnerability detected")
        
        # XSS indicators
        if '<script>' in content or 'alert(' in content:
            indicators.append("üîç Possible XSS vulnerability detected")
        
        # Error disclosure
        if any(error in content for error in ['error', 'exception', 'stack trace', 'debug']):
            indicators.append("üîç Error information disclosure detected")
        
        # Directory traversal
        if 'root:' in content or '[boot loader]' in content:
            indicators.append("üîç Possible directory traversal vulnerability")
        
        # Command injection
        if any(cmd in content for cmd in ['uid=', 'gid=', 'groups=', 'volume serial number']):
            indicators.append("üîç Possible command injection vulnerability")
        
        if indicators:
            print(f"\\nüö® VULNERABILITY INDICATORS:")
            for indicator in indicators:
                print(f"  {indicator}")
        else:
            print(f"\\n‚úÖ No obvious vulnerability indicators found")
    
    def run_multiple_attempts(self, count=3):
        """Run multiple attack attempts with variations."""
        print(f"\\nüîÑ Running {count} attack attempts...")
        
        for i in range(count):
            print(f"\\n--- Attempt {i+1}/{count} ---")
            self.simulate_attack()
            
            if i < count - 1:  # Don't sleep after last attempt
                sleep_time = random.uniform(1, 3)
                print(f"‚è±Ô∏è  Waiting {sleep_time:.1f} seconds before next attempt...")
                time.sleep(sleep_time)

def main():
    print("üéØ AttackReplay Pro - Advanced Attack Simulator")
    print("=" * 70)
    
    # Configuration - CHANGE THESE VALUES FOR YOUR TARGET
    TARGET_URL = "http://your-target-website.com"  # ‚ö†Ô∏è CHANGE THIS
    ATTACK_ATTEMPTS = 1  # Number of attack attempts
    
    # Validate target URL
    if TARGET_URL == "http://your-target-website.com":
        print("‚ùå ERROR: Please change TARGET_URL to your actual target!")
        print("   Edit this script and set TARGET_URL to your test website.")
        sys.exit(1)
    
    # Create simulator instance
    simulator = AttackSimulator(TARGET_URL)
    
    # Print banner and run attack
    simulator.print_banner()
    
    # Ask for confirmation
    confirm = input("\\n‚ö†Ô∏è  Are you authorized to test this target? (yes/no): ").lower()
    if confirm != 'yes':
        print("‚ùå Attack cancelled. Only test systems you own or have permission to test.")
        sys.exit(1)
    
    # Run the attack simulation
    if ATTACK_ATTEMPTS == 1:
        simulator.simulate_attack()
    else:
        simulator.run_multiple_attempts(ATTACK_ATTEMPTS)
    
    print("\\n‚úÖ Attack simulation completed!")
    print("üìù Review the results above for vulnerability indicators.")

if __name__ == "__main__":
    main()
'''
        
        return script

    def generate_batch_attack_script(self, attacks: List[Dict[str, any]]) -> str:
        """Generate a batch script that runs multiple attacks."""
        
        script = '''#!/usr/bin/env python3
"""
Batch Attack Simulation Script
Generated by AttackReplay Pro

DISCLAIMER: This script is for authorized security testing only.
Only use on systems you own or have explicit permission to test.
"""

import requests
import time
import random
import sys
from datetime import datetime
from urllib.parse import urlparse

class BatchAttackSimulator:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.results = []
        
        # Set up session
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Connection": "keep-alive"
        })
    
    def run_attack_sequence(self):
        """Run all detected attacks in sequence."""
        attacks = [
'''
        
        # Add attack data
        for i, attack in enumerate(attacks):
            attack_data = {
                'type': attack.get('attack_type', 'Unknown'),
                'path': urlparse(attack.get('full_url', '')).path or '/',
                'query': urlparse(attack.get('full_url', '')).query or '',
                'method': attack.get('method', 'GET'),
                'payload': attack.get('matched_payload', '')
            }
            script += f"            {attack_data},\n"
        
        script += '''        ]
        
        print(f"üéØ Starting batch attack simulation with {len(attacks)} attacks")
        print(f"Target: {self.target_url}")
        print("=" * 70)
        
        for i, attack in enumerate(attacks, 1):
            print(f"\\n[{i}/{len(attacks)}] Executing {attack['type']} attack...")
            
            try:
                # Construct URL
                if attack['query']:
                    full_url = f"{self.target_url}{attack['path']}?{attack['query']}"
                else:
                    full_url = f"{self.target_url}{attack['path']}"
                
                print(f"  URL: {full_url}")
                print(f"  Method: {attack['method']}")
                
                # Execute attack
                start_time = time.time()
                if attack['method'].upper() == 'GET':
                    response = self.session.get(full_url, timeout=10, verify=False)
                elif attack['method'].upper() == 'POST':
                    response = self.session.post(full_url, timeout=10, verify=False)
                else:
                    response = self.session.request(attack['method'], full_url, timeout=10, verify=False)
                
                end_time = time.time()
                
                # Record result
                result = {
                    'attack_type': attack['type'],
                    'status_code': response.status_code,
                    'response_time': end_time - start_time,
                    'content_length': len(response.content),
                    'success': response.status_code < 400
                }
                self.results.append(result)
                
                print(f"  ‚úÖ Status: {response.status_code} | Time: {result['response_time']:.2f}s | Size: {result['content_length']} bytes")
                
            except Exception as e:
                print(f"  ‚ùå Failed: {e}")
                self.results.append({
                    'attack_type': attack['type'],
                    'status_code': 0,
                    'response_time': 0,
                    'content_length': 0,
                    'success': False,
                    'error': str(e)
                })
            
            # Random delay between attacks
            if i < len(attacks):
                delay = random.uniform(0.5, 2.0)
                time.sleep(delay)
        
        self.print_summary()
    
    def print_summary(self):
        """Print attack summary."""
        print("\\n" + "=" * 70)
        print("üìä BATCH ATTACK SUMMARY")
        print("=" * 70)
        
        total_attacks = len(self.results)
        successful_attacks = sum(1 for r in self.results if r['success'])
        failed_attacks = total_attacks - successful_attacks
        
        print(f"Total Attacks: {total_attacks}")
        print(f"Successful: {successful_attacks}")
        print(f"Failed: {failed_attacks}")
        print(f"Success Rate: {(successful_attacks/total_attacks)*100:.1f}%")
        
        print("\\nAttack Results:")
        for result in self.results:
            status = "‚úÖ" if result['success'] else "‚ùå"
            print(f"  {status} {result['attack_type']}: Status {result['status_code']}")

def main():
    # Configuration - CHANGE THIS
    TARGET_URL = "http://your-target-website.com"  # ‚ö†Ô∏è CHANGE THIS
    
    if TARGET_URL == "http://your-target-website.com":
        print("‚ùå ERROR: Please change TARGET_URL to your actual target!")
        sys.exit(1)
    
    # Confirmation
    print("üéØ AttackReplay Pro - Batch Attack Simulator")
    print(f"Target: {TARGET_URL}")
    confirm = input("\\n‚ö†Ô∏è  Are you authorized to test this target? (yes/no): ").lower()
    if confirm != 'yes':
        print("‚ùå Attack cancelled.")
        sys.exit(1)
    
    # Run attacks
    simulator = BatchAttackSimulator(TARGET_URL)
    simulator.run_attack_sequence()

if __name__ == "__main__":
    main()
'''
        
        return script

    def generate_curl_command(self, attack: Dict[str, any]) -> str:
        raw_url = attack.get('full_url', '')
        method = attack.get('method', 'GET')
        user_agent = attack.get('user_agent', 'Mozilla/5.0')
        
        parsed_url = urlparse(raw_url)
        if parsed_url.scheme:
            full_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
            if parsed_url.query:
                full_url += f"?{parsed_url.query}"
        else:
            full_url = f"http://example.com{raw_url}"
        
        curl_cmd = f'curl -X {method} \\\n'
        curl_cmd += f'  -H "User-Agent: {user_agent}" \\\n'
        curl_cmd += f'  -i \\\n'
        curl_cmd += f'  "{full_url}"'
        
        return curl_cmd

    def save_replay_scripts(self, attacks: List[Dict[str, any]]) -> Dict[str, List[str]]:
        """Save advanced attack simulation scripts."""
        generated_files = {
            'python_scripts': [],
            'curl_commands': [],
            'batch_script': None,
            'readme': None
        }
        
        # Generate individual attack scripts
        for idx, attack in enumerate(attacks, 1):
            attack_type = attack.get('attack_type', 'Unknown').replace(' ', '_').replace('/', '_')
            
            # Advanced Python script
            python_script = self.generate_advanced_python_script(attack, idx)
            python_filename = f"{self.output_dir}/attack_{idx:02d}_{attack_type}.py"
            with open(python_filename, 'w', encoding='utf-8') as f:
                f.write(python_script)
            try:
                os.chmod(python_filename, 0o755)
            except (OSError, AttributeError):
                # Windows doesn't support chmod the same way
                pass
            generated_files['python_scripts'].append(python_filename)
            
            # Enhanced curl command
            curl_command = self.generate_enhanced_curl_command(attack)
            curl_filename = f"{self.output_dir}/attack_{idx:02d}_{attack_type}.sh"
            with open(curl_filename, 'w', encoding='utf-8') as f:
                f.write("#!/bin/bash\n")
                f.write(f"# Advanced Attack Simulation - {attack.get('attack_type', 'Unknown')}\n")
                f.write(f"# Generated by AttackReplay Pro\n")
                f.write(f"# Original IP: {attack.get('ip', '')}\n")
                f.write(f"# Timestamp: {attack.get('timestamp', '')}\n\n")
                f.write("# CHANGE TARGET_URL BEFORE RUNNING\n")
                f.write("TARGET_URL=\"http://your-target-website.com\"\n\n")
                f.write("if [ \"$TARGET_URL\" = \"http://your-target-website.com\" ]; then\n")
                f.write("    echo \"‚ùå ERROR: Please change TARGET_URL to your actual target!\"\n")
                f.write("    exit 1\nfi\n\n")
                f.write(curl_command)
                f.write("\n")
            try:
                os.chmod(curl_filename, 0o755)
            except (OSError, AttributeError):
                # Windows doesn't support chmod the same way
                pass
            generated_files['curl_commands'].append(curl_filename)
        
        # Generate batch attack script
        if len(attacks) > 1:
            batch_script = self.generate_batch_attack_script(attacks)
            batch_filename = f"{self.output_dir}/batch_attack_all.py"
            with open(batch_filename, 'w', encoding='utf-8') as f:
                f.write(batch_script)
            try:
                os.chmod(batch_filename, 0o755)
            except (OSError, AttributeError):
                # Windows doesn't support chmod the same way
                pass
            generated_files['batch_script'] = batch_filename
        
        # Generate README with instructions
        readme_content = self.generate_readme(attacks, generated_files)
        readme_filename = f"{self.output_dir}/README.md"
        with open(readme_filename, 'w', encoding='utf-8') as f:
            f.write(readme_content)
        generated_files['readme'] = readme_filename
        
        return generated_files

    def generate_enhanced_curl_command(self, attack: Dict[str, any]) -> str:
        """Generate enhanced curl command with target URL variable."""
        raw_url = attack.get('full_url', '')
        method = attack.get('method', 'GET')
        user_agent = attack.get('user_agent', 'Mozilla/5.0')
        
        parsed_url = urlparse(raw_url)
        path = parsed_url.path or '/'
        query = parsed_url.query or ''
        
        if query:
            full_path = f"{path}?{query}"
        else:
            full_path = path
        
        curl_cmd = f'echo "üéØ Executing {attack.get("attack_type", "Unknown")} attack..."\n'
        curl_cmd += f'curl -X {method} \\\n'
        curl_cmd += f'  -H "User-Agent: {user_agent}" \\\n'
        curl_cmd += f'  -H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \\\n'
        curl_cmd += f'  -H "Accept-Language: en-US,en;q=0.5" \\\n'
        curl_cmd += f'  -w "\\nStatus: %{{http_code}}\\nTime: %{{time_total}}s\\nSize: %{{size_download}} bytes\\n" \\\n'
        curl_cmd += f'  -i \\\n'
        curl_cmd += f'  -k \\\n'  # Ignore SSL errors
        curl_cmd += f'  --max-time 15 \\\n'
        curl_cmd += f'  "$TARGET_URL{full_path}"'
        
        return curl_cmd

    def generate_readme(self, attacks: List[Dict[str, any]], generated_files: Dict[str, List[str]]) -> str:
        """Generate comprehensive README for attack scripts."""
        
        readme = f'''# AttackReplay Pro - Generated Attack Scripts

## ‚ö†Ô∏è IMPORTANT DISCLAIMER

**These scripts are for authorized security testing only!**

- Only use on systems you own or have explicit written permission to test
- Unauthorized use is illegal and unethical
- Always follow responsible disclosure practices
- Use these tools to improve security, not to cause harm

## üìÅ Generated Files

This directory contains {len(attacks)} attack simulation scripts based on detected threats:

### Individual Attack Scripts
'''
        
        for i, script in enumerate(generated_files['python_scripts'], 1):
            attack = attacks[i-1] if i-1 < len(attacks) else {}
            script_name = os.path.basename(script)
            readme += f"- `{script_name}` - {attack.get('attack_type', 'Unknown')} attack simulation\n"
        
        if generated_files['batch_script']:
            readme += f"\n### Batch Attack Script\n"
            readme += f"- `{os.path.basename(generated_files['batch_script'])}` - Run all attacks in sequence\n"
        
        readme += f'''
### Shell Scripts (curl)
- `attack_*.sh` - Curl-based attack scripts for each detected threat

## üöÄ Quick Start

### 1. Choose Your Target
Edit the scripts and change the target URL:
```python
TARGET_URL = "http://your-target-website.com"  # Change this!
```

### 2. Run Individual Attacks
```bash
# Make script executable
chmod +x attack_01_SQL_Injection.py

# Run the attack
python3 attack_01_SQL_Injection.py
```

### 3. Run All Attacks (Batch)
```bash
# Run all attacks in sequence
python3 batch_attack_all.py
```

### 4. Using Curl Scripts
```bash
# Run curl-based attack
./attack_01_SQL_Injection.sh
```

## üìä Attack Summary

Total attacks detected: **{len(attacks)}**

Attack breakdown:
'''
        
        # Add attack type breakdown
        attack_counts = {}
        for attack in attacks:
            attack_type = attack.get('attack_type', 'Unknown')
            attack_counts[attack_type] = attack_counts.get(attack_type, 0) + 1
        
        for attack_type, count in attack_counts.items():
            readme += f"- **{attack_type}**: {count} attack(s)\n"
        
        readme += f'''

## üîß Script Features

### Advanced Python Scripts
- **Realistic simulation**: Mimics real attack behavior
- **Vulnerability detection**: Analyzes responses for indicators
- **Multiple attempts**: Can run multiple attack variations
- **Detailed reporting**: Shows response analysis and timing
- **Error handling**: Graceful handling of network issues
- **Random delays**: Avoids detection by security systems

### Enhanced Curl Scripts
- **Target URL variables**: Easy to change target
- **Comprehensive headers**: Realistic browser simulation
- **Response analysis**: Shows status, timing, and size
- **SSL handling**: Ignores certificate errors for testing

## üìã Usage Examples

### Testing SQL Injection
```bash
python3 attack_01_SQL_Injection.py
```
This will:
1. Connect to your target website
2. Execute the SQL injection payload
3. Analyze the response for vulnerability indicators
4. Report findings with detailed analysis

### Batch Testing
```bash
python3 batch_attack_all.py
```
This will:
1. Run all detected attacks in sequence
2. Add random delays between attacks
3. Provide a comprehensive summary report
4. Show success/failure rates

## üõ°Ô∏è Security Testing Best Practices

1. **Get Permission**: Always get written authorization before testing
2. **Test Safely**: Use isolated test environments when possible
3. **Monitor Impact**: Watch for service disruption during testing
4. **Document Findings**: Keep detailed records of vulnerabilities found
5. **Report Responsibly**: Follow responsible disclosure practices
6. **Fix Issues**: Prioritize fixing found vulnerabilities

## üîç Understanding Results

### Vulnerability Indicators
The scripts look for common vulnerability indicators:

- **SQL Injection**: Database error messages, syntax errors
- **XSS**: Script execution, alert dialogs
- **Directory Traversal**: System file contents
- **Command Injection**: System command output
- **Error Disclosure**: Stack traces, debug information

### Response Analysis
Each script provides:
- HTTP status codes
- Response timing
- Content length
- Response headers
- Content preview
- Vulnerability indicators

## üìû Support

Generated by AttackReplay Pro - Advanced Web Application Security Testing Platform

For more information about the original attacks, check the analysis results in your AttackReplay Pro dashboard.

---
**Remember: Use these tools responsibly and only on systems you're authorized to test!**
'''
        
        return readme

    def generate_summary_report(self, analysis_results: Dict[str, any], generated_files: Dict[str, List[str]]) -> str:
        report = {
            "analysis_timestamp": str(os.path.getmtime(__file__)) if os.path.exists(__file__) else "N/A",
            "total_attacks_detected": analysis_results.get('total_attacks', 0),
            "unique_ips": analysis_results.get('unique_ips', 0),
            "attack_breakdown": analysis_results.get('attack_type_counts', {}),
            "generated_files": generated_files,
            "attacks": analysis_results.get('attacks', [])
        }
        
        report_filename = f"{self.output_dir}/attack_summary.json"
        with open(report_filename, 'w') as f:
            json.dump(report, f, indent=2)
        
        return report_filename

    def clean_output_directory(self):
        if os.path.exists(self.output_dir):
            for file in os.listdir(self.output_dir):
                file_path = os.path.join(self.output_dir, file)
                if os.path.isfile(file_path):
                    os.remove(file_path)
